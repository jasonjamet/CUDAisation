\documentclass{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{float}
\restylefloat{figure}
\usepackage[frenchb]{babel}
\usepackage[nopostdot]{glossaries}
\makeglossaries
\usepackage{xcolor,listings}
\usepackage{color}
\definecolor{maroon}{rgb}{0.5,0,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}


\renewcommand\lstlistingname{Code}

\lstdefinelanguage{XML}
{
  basicstyle=\normalfont\ttfamily,
  numbers=left,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  frame=lines,
  backgroundcolor=\color{background},
  morestring=[s]{"}{"},
  morecomment=[s]{?}{?},
  morecomment=[s]{!--}{--},
  commentstyle=\color{darkgreen},
  moredelim=[s][\color{black}]{>}{<},
  moredelim=[s][\color{red}]{\ }{=},
  stringstyle=\color{blue},
  captionpos=b,
  identifierstyle=\color{maroon}
}
\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    captionpos=b,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    stringstyle=\color{blue},
    morestring=[s]{"}{"},
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{blue}0}}}{1}
      {1}{{{\color{blue}1}}}{1}
      {2}{{{\color{blue}2}}}{1}
      {3}{{{\color{blue}3}}}{1}
      {4}{{{\color{blue}4}}}{1}
      {5}{{{\color{blue}5}}}{1}
      {6}{{{\color{blue}6}}}{1}
      {7}{{{\color{blue}7}}}{1}
      {8}{{{\color{blue}8}}}{1}
      {9}{{{\color{blue}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dred}{rgb}{0.545,0,0}
\definecolor{dblue}{rgb}{0,0,0.545}
\definecolor{lgrey}{rgb}{0.9,0.9,0.9}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\lstdefinelanguage{cpp}{
      backgroundcolor=\color{lgrey},  
      basicstyle=\footnotesize \ttfamily \color{black} \bfseries,   
      breakatwhitespace=false,       
      breaklines=true,               
      captionpos=b,                   
      commentstyle=\color{dkgreen},   
      deletekeywords={...},          
      escapeinside={\%*}{*)},                  
      frame=single,                  
      language=C++,                
      keywordstyle=\color{purple},  
      morekeywords={BRIEFDescriptorConfig,string,TiXmlNode,DetectorDescriptorConfigContainer,istringstream,cerr,exit}, 
      identifierstyle=\color{black},
      stringstyle=\color{blue},      
      numbers=right,                 
      numbersep=5pt,                  
      numberstyle=\tiny\color{black}, 
      rulecolor=\color{black},        
      showspaces=false,               
      showstringspaces=false,        
      showtabs=false,                
      stepnumber=1,                   
      tabsize=5,                     
      title=\lstname,                 
    }


\begin{document}

	\begin{titlepage}
		\begin{center}
		
			\includegraphics[scale=0.4]{cuda_logo.jpg}
			\hspace*{3in}
			\includegraphics[scale=0.08]{angers.jpg}
			\\[4cm]
			\begin{Huge}
				\rule{\linewidth}{0.5mm} \\[0.4cm]
				CUDAisation du code impératif
				\rule{\linewidth}{0.5mm} \\[0.3cm]
				
			\end{Huge}
			\begin{Large}
				POC (Proof of Concept) pour la génération de kernel à partir de code impératif
			\end{Large}		
			 
		\end{center}
		
		
  		\begin{figure}[b]
  		 \begin{minipage}{0.4\textwidth}
			\begin{flushleft} \large
				Alexis BRIARD\\
				Guillaume GRANDJEAN\\
				Jason JAMET
    		\end{flushleft}
    		\end{minipage}
    		\begin{minipage}{0.6\textwidth}
			\begin{flushright} \large
				\emph{Tuteur pédagogique:} Jean Michel RICHER\\				
        		Université d'Angers\\
        		\today
    		\end{flushright}
    	\end{minipage}
		\end{figure}

    	
	\end{titlepage}



\newpage
\thispagestyle{empty}
\mbox{}
\setcounter{page}{0}
\glsresetall
\newpage
\tableofcontents
\newpage

	\section{Objectifs}

	\paragraph{}
	Le but du projet était de pouvoir mettre en oeuvre une étude de faisabilité, ou POC (Proof of Concept) afin de montrer comment transformer du code impératif vers CUDA.
	
	\begin{lstlisting}[
    language=cpp,
]
#pragma cuda thread_loop(i) params(x,y,z,size) 
void sum(float *x, float *y, float *z, int size) { 
	for (int i=0; i<size; ++i) {
		z[i] = x[i] + y[i];
	}
}

_____________________________________


__global__ void kernel(float *x, float *y, float *z, int size) { 
	int gtid = ...
	if (gtid < size) {
		z[i] = x[i] + y[i];
	}
}
	
	\end{lstlisting}	
	
	
	\section{Analyse du problème}
	
	Nous avons commencé par identifier les différents problèmes que nous pourrions rencontrer lors de la transformation d'une fonction lambda vers CUDA.
	
	
	En effet, tout les cas ne peuvent fonctionner, et il faut bien évidemment prendre en compte tous les paramètres qui peuvent intervenir :

	Liste des fonctionnalités a implementer
	Liste des cas a exclures
	\paragraph{Problèmes exclus}
	\begin{itemize}
  		\item Boucle while
  		\item Fonction non void
  		\item Plusieurs boucles for imbriquées	
	\end{itemize}
	
	\paragraph{Problèmes potentiel}
		\begin{itemize}
  		\item Conditions if else
  		\item Passage de variables vers CUDA et inverse
  		\item Création de la grille/blocs/threads (tailles)
  		\item Incrémentation dans la boucle for
  		\item Taille de la boucle plus grande que la grille
  		\item Boucles imbriquées
  		\item Variables globales
	\end{itemize}
	\paragraph{Fonction non void}
	Une fonction CUDA ne peut pas retourner de valeurs, nous avons donc trouvé judicieux de ne pas traiter les fonction ayant un retour, la contrainte est de plus extremement minime pour l'utilisateur.
	
	\newpage	
	
	\section{Solutions}
	

	\subsection{Solutions envisagées}
	
		Afin de réaliser le projet, nous nous sommes penché sur les différentes solutions possibles qu'il existait et avons cherché les pour et les contres :
	\paragraph{Analyseur syntaxique/lexical}
	~~\\
	\indent
	Le principe est de parser le fichier contenant notre fonction à paralleliser grâce à des outils d'analyse tel que flex (analyseur lexical) et bison (analyseur syntaxique).\\
	Le résultat de l'analyse est alors stocké dans un arbre pouvant être modifié selon nos besoins.\\
	La transformation peut ce faire lors de l'analyse (et création de l'arbre), lors d'un traitement annexe ou lors de l'affichage.\\
	Cette solution est très adaptée à notre problème, elle peut cependant devenir complexe techniquement si le langage à parser est complet.
	
	\paragraph{Regex}
	~~\\
	\indent
	Basé sur le même principe que l'idée précédente, la création de l'arbre ne ce ferais plus via des outils, mais manuellement grâce à des expressions régulières.\\
	Cette solution à pour inconvénient d'être très abordable techniquement, mais à tendance à vite devenir complexe (du notamment à l'absence d'analyseur synthaxique).
	
	\paragraph{Compilateur gcc}
	~~\\
	\indent
	Utiliser l'aptitude du compilateur gcc à accueillir des plugins, il existe un plugin baptisé "PLUGIN\_PRAGMAS" permettant l'intégration de pragma personnalisé, il est alors possible d'effectuer des actions spécifique en fonction du pragma renseigné. \\
	Ce principe est notamment utilisé pour le pragma d'OpenMp, et cette solution correspondrais parfaitement à notre problème.
	
	\subsection{Solution retenue}
	~~\\
	\indent
	La courbe d'apprentissage pour apréhender l'utilisation et la confection de plugin gcc nous à parut trop longue pour un projet aussi court, c'est pour cela que nous avons opté pour la solution utilisant les analyses syntaxique et lexicales qui à pour avantage d'être connue et plus ou moin maitrisée par les membres de l'équipe.
	

	
	
	\newpage
	
	
	
	
	\section{Implémentations}
	
	Parler des fonctionnalitées implémentées.
	Palrer des différentes appoches de traitement (pre abre post arbre)

	\newpage



	
	
	
	\section{Améliorations}
	
	\section{Conclusion}
	
	Parler de montée en compétence..
	
	
	\section*{Figures}
\indent
\textbf{Figure \ref{fig:KaliGanttPrev}} Diagramme de gantt prévisionnel\\
\indent

\section*{Code}

\indent
\textbf{Code \ref{cod:apiREST}} Exemple de retour de l'api REST\\
\indent

\newglossaryentry{aikau}{name={AIKAU},
    description={Framework Open source JavaScript réalisé pour alfresco}}
\newglossaryentry{amp}{name={AMP},
    description={Alfresco Module Package: Collection de code, \gls{xml}, images... Format compressé pouvant  être appliqué à un fichier war.}}
    


\section*{Glossaire}
\renewcommand{\glossarysection}[2][]{}

\printglossary[title=List of Terms,toctitle=Terms and abbreviations]



\section*{Bibliographie}
\begin{itemize}

\item https://github.com/dnoliver/tc-parser/tree/e3c06751c2bca8a9aaea8afe601a7ad05b3384a4
\item http://www.quut.com/c/ANSI-C-grammar-y.html
\item https://gcc.gnu.org/onlinedocs/gccint/Plugins-attr.html\#Plugins-attr

\end{itemize}
	
problemes:

structure
cast
grid_size(1,,2);

\newpage
	\section{Annexe}

	\subsection{Exemple}

	\begin{lstlisting}[
    language=cpp,
]
int x1 = 2;
int y2 = 2;



#pragma cuda thread_loop(j) block_size(x1,y2) grid_size(16,16)
void sum(float *x, float *y, float *z, int size) {
 int i;
 for(i=0; i<size; ++i) {
   z[i] = x[i] + y[i];
 }
 int j;
 for(j=0; j<size; j++) {
    z[i] = x[i] + y[i];
 }
}

int main() {
  return 0;
}



_____________________________________


int x1 = 2;
int y2 = 2;

__global__
void kernel_sum(float *x, float *y, float *z, int size)
{
	int i;
	for ( i = 0; i < size; ++i )
	{
		z[i] = x[i] + y[i];
	}
	int j = (((blockIdx.x * gridDim.y + blockIdx.y) * blockDim.x + threadIdx.x) * blockDim.y + threadIdx.y);
	if (j < size)
	{
		z[i] = x[i] + y[i];
	}
}
void sum(float *x, float *y, float *z, int size)
{
	 kernel_sum <<< dim3((16 + x1*y2 - 1 ) / x1*y2, (16 + x1*y2 - 1 ) / x1*y2), dim3(x1, y2) >>> (x, y, z, size);
}
int main()
{
	return 0;
}
\end{lstlisting}


\end{document}

